-- Шаг 1: Создаем полную таблицу диапазонов
create table tmp_date_ranges as
select distinct 
    report_date,
    report_date - 64 as start_date,
    report_date as end_date,
    -- Дополнительные колонки для статистики
    count(*) over (partition by report_date) as accounts_count
from ema_scoped_accounts;

-- Шаг 2: Индексы
create index idx_tmp_ranges_dates on tmp_date_ranges(start_date, end_date);
create index idx_tmp_ranges_report on tmp_date_ranges(report_date);

-- Шаг 3: Анализируем статистику
begin
    dbms_stats.gather_table_stats(
        ownname => USER,
        tabname => 'TMP_DATE_RANGES',
        estimate_percent => 100,
        cascade => true
    );
end;
/

-- Шаг 4: Оптимизированный запрос с подсказками
drop table ema_balance_scope;

create table ema_balance_scope nologging parallel 4 as 
select /*+ LEADING(d) USE_NL(b) INDEX(b idx_bal_dt_uid) */
       sa.client_did,
       sa.report_date, 
       b.ACC_BAL_OPER_DT,
       sum(b.ACC_BAL_CLOSE_BAL_RUB_AMT) as balance_rub, 
       sum(b.ACC_BAL_CR_RUB_AMT) as credit_turnover_rub,
       sum(b.ACC_BAL_DB_RUB_AMT) as debit_turnover_rub
from tmp_date_ranges d
join dm_rrb.dm_rrb_au_account_balance b
  on b.ACC_BAL_OPER_DT between d.start_date and d.end_date
join ema_scoped_accounts sa
  on sa.ACC_UID = b.ACC_BAL_ACC_UID
  and sa.report_date = d.report_date
group by sa.client_did, sa.report_date, b.ACC_BAL_OPER_DT;

-- Шаг 5: Очистка временных объектов
drop table tmp_date_ranges;
