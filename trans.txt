import numpy as np
import pandas as pd
from typing import Dict, Union, Tuple, Optional
from sklearn.metrics import roc_curve, roc_auc_score
import plotly.graph_objects as go

ArrayLike = Union[np.ndarray, list, pd.Series]

def plot_roc_curve_plotly(
    y_true: ArrayLike,
    scores: Union[ArrayLike, Dict[str, ArrayLike]],
    *,
    pos_label=1,
    sample_weight: Optional[ArrayLike] = None,
    title: str = "ROC curve (Plotly)"
) -> Tuple[pd.DataFrame, go.Figure]:
    """
    Plotly-версия RocCurveDisplay.
    
    y_true:     истинные метки (0/1)
    scores:     либо 1 массив предсказанных вероятностей/скорингов,
                либо dict {'Model A': scores_a, 'Model B': scores_b, ...}
                Для бинарной модели допускается форма (n_samples, 2) -> возьмётся колонка позитивного класса.
    pos_label:  какое значение считать позитивным
    sample_weight: веса наблюдений (опционально)
    
    Возвращает:
      df_points: DataFrame с колонками [model, fpr, tpr, threshold, auc]
      fig:       plotly.graph_objects.Figure
    """
    y_true = np.asarray(y_true)

    # унифицируем в словарь "имя -> скор"
    if not isinstance(scores, dict):
        scores = {"Model": scores}

    traces = []
    rows = []

    for name, s in scores.items():
        s = np.asarray(s)
        # если подали (n,2) вероятности — берём для pos_label
        if s.ndim == 2 and s.shape[1] >= 2:
            # предполагаем, что колонка pos_label=1 — это колонка 1
            # при другом значении pos_label можно поменять индекс
            col = 1 if pos_label == 1 else 0
            s = s[:, col]

        # ROC точки
        fpr, tpr, thr = roc_curve(y_true, s, pos_label=pos_label, sample_weight=sample_weight)
        auc = roc_auc_score(y_true, s, average="macro", sample_weight=sample_weight)

        # копим строки таблицы
        rows.append(pd.DataFrame({
            "model": name,
            "fpr": fpr,
            "tpr": tpr,
            "threshold": thr,
            "auc": auc
        }))

        # интерактивный трейс
        hover = (
            "<b>%s</b><br>"
            "FPR: %{x:.3f}<br>"
            "TPR: %{y:.3f}<br>"
            "Threshold: %{customdata:.3f}<br>"
            "Specificity: %{customdata2:.3f}"  # 1 - FPR
        ) % name

        traces.append(go.Scatter(
            x=fpr,
            y=tpr,
            mode="lines",
            name=f"{name} (AUC={auc:.3f})",
            customdata=thr,
            customdata2=1 - fpr,
            hovertemplate=hover,
            line=dict(width=3)
        ))

    df_points = pd.concat(rows, ignore_index=True)

    # диагональ "chance"
    chance = go.Scatter(
        x=[0, 1], y=[0, 1],
        mode="lines",
        name="Chance",
        line=dict(width=2, dash="dash", color="#888"),
        hoverinfo="skip",
        showlegend=True
    )

    # рисуем
    fig = go.Figure([chance] + traces)
    fig.update_layout(
        title=title,
        xaxis=dict(title="False Positive Rate (FPR)", range=[0, 1], constrain="domain"),
        yaxis=dict(title="True Positive Rate (TPR)",  range=[0, 1]),
        template="plotly_white",
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        margin=dict(t=70, r=30, b=50, l=60),
        hovermode="x unified"
    )
    fig.show()
    return df_points, fig
