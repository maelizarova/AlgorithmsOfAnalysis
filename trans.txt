import pandas as pd
import numpy as np

def optimize_dataframe(df, categorical_threshold=0.5, verbose=True):
    """
    Оптимизирует DataFrame, уменьшая использование памяти за счёт преобразования типов данных.
    
    Параметры:
    - df: Исходный DataFrame
    - categorical_threshold: Порог (0-1) для преобразования в категориальный тип
    - verbose: Выводить информацию об оптимизации
    
    Возвращает:
    - Оптимизированный DataFrame
    """
    
    optimized_df = df.copy()
    date_cols = []
    
    for col in optimized_df.columns:
        col_type = optimized_df[col].dtype
        col_values = optimized_df[col]
        
        # Оптимизация целых чисел
        if pd.api.types.is_integer_dtype(col_type):
            col_min = col_values.min()
            col_max = col_values.max()
            
            if col_min > np.iinfo(np.int8).min and col_max < np.iinfo(np.int8).max:
                optimized_df[col] = col_values.astype(np.int8)
            elif col_min > np.iinfo(np.int16).min and col_max < np.iinfo(np.int16).max:
                optimized_df[col] = col_values.astype(np.int16)
            elif col_min > np.iinfo(np.int32).min and col_max < np.iinfo(np.int32).max:
                optimized_df[col] = col_values.astype(np.int32)
        
        # Оптимизация чисел с плавающей точкой
        elif pd.api.types.is_float_dtype(col_type):
            col_min = col_values.min()
            col_max = col_values.max()
            
            if col_min > np.finfo(np.float16).min and col_max < np.finfo(np.float16).max:
                optimized_df[col] = col_values.astype(np.float16)
            elif col_min > np.finfo(np.float32).min and col_max < np.finfo(np.float32).max:
                optimized_df[col] = col_values.astype(np.float32)
        
        # Преобразование строк в категории
        elif pd.api.types.is_string_dtype(col_type):
            num_unique = col_values.nunique()
            if num_unique / len(col_values) < categorical_threshold:
                optimized_df[col] = col_values.astype('category')
        
        # Преобразование в datetime (если уже похоже на datetime)
        elif pd.api.types.is_datetime64_any_dtype(col_type):
            try:
                converted = pd.to_datetime(col_values)
                optimized_df[col] = converted
                date_cols.append(col)
            except:
                pass
    
    # Вывод информации
    if verbose:
        original_mem = df.memory_usage(deep=True).sum() / 1024**2
        optimized_mem = optimized_df.memory_usage(deep=True).sum() / 1024**2
        reduction = (original_mem - optimized_mem) / original_mem * 100
        
        print(f"Оптимизация памяти:")
        print(f"До: {original_mem:.2f} MB")
        print(f"После: {optimized_mem:.2f} MB")
        print(f"Экономия: {reduction:.1f}%")
        if date_cols:
            print(f"Обнаружены datetime колонки: {date_cols}")
    
    return optimized_df
