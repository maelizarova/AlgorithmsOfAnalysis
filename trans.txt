import numpy as np
import pandas as pd
import plotly.graph_objects as go
from typing import Tuple

def plot_lift_plotly(
    df: pd.DataFrame,
    pred_col: str,
    target_col: str,
    *,
    q: int = 10,
    name: str = "Лифт",
    show: bool = True
) -> Tuple[pd.DataFrame, go.Figure]:
    """
    Лифт по децилям предсказанного скора.
    Возвращает (df_lift, fig).

    df_lift колонки:
      bucket (1..q), count, true_count, share_true_pct,
      mean_target, mean_score, mean_overall, lift
    """

    data = df[[pred_col, target_col]].dropna().copy()

    # Децильные "бакеты" по предсказанию
    # метки делаем 1..q (1 = низкие скора, q = высокие)
    data["bucket"] = pd.qcut(data[pred_col], q=q, labels=range(1, q + 1), duplicates="drop")

    # Агрегация по бакетам
    g = (
        data.groupby("bucket", observed=False)
            .agg(
                mean_target=(target_col, "mean"),
                mean_score=(pred_col, "mean"),
                count=(target_col, "size"),
                true_count=(target_col, "sum"),
            )
            .reset_index()
            .astype({"bucket": int})
            .sort_values("bucket")
    )

    mean_overall = data[target_col].mean()
    g["mean_overall"] = mean_overall
    g["lift"] = g["mean_target"] / mean_overall if mean_overall > 0 else 0.0

    total_true = data[target_col].sum()
    g["share_true_pct"] = np.where(total_true > 0, g["true_count"] / total_true * 100.0, 0.0)

    # ------- Рисуем -------
    fig = go.Figure()

    # Бар: Lift (левая ось)
    fig.add_bar(
        x=g["bucket"], y=g["lift"],
        name="Lift",
        marker_color="silver",
        text=[f"{c/1000:.1f}k" for c in g["count"]],   # подписи количества над столбцами
        textposition="outside",
        cliponaxis=False
    )

    # Линии: средний таргет в бакете, средний скор, средний по выборке (константа), правая ось
    fig.add_trace(go.Scatter(
        x=g["bucket"], y=g["mean_target"],
        mode="lines", name="Средний таргет в бакете",
        yaxis="y2", line=dict(width=3)
    ))
    fig.add_trace(go.Scatter(
        x=g["bucket"], y=g["mean_score"],
        mode="lines", name="Средний скор в бакете",
        yaxis="y2", line=dict(width=3, color="#FF7F0E")
    ))
    fig.add_trace(go.Scatter(
        x=g["bucket"], y=g["mean_overall"],
        mode="lines", name="Средний таргет в выборке",
        yaxis="y2", line=dict(width=2, dash="dash", color="#2ca02c")
    ))

    # Подписи «Доля true единиц» под осью X
    fig.add_annotation(
        xref="paper", yref="paper", x=0, y=-0.16,
        text="Доля true единиц", showarrow=False, align="left"
    )
    for x_i, pct in zip(g["bucket"], g["share_true_pct"]):
        fig.add_annotation(
            x=x_i, yref="paper", y=-0.22,
            text=f"{pct:.1f}%", showarrow=False
        )

    # Оси и оформление
    ymax = float(max(1.0, g["lift"].max()))
    fig.update_layout(
        title=f"{name}",
        xaxis=dict(title="Бакеты", tickmode="array", tickvals=g["bucket"]),
        yaxis=dict(title="Лифт", range=[0, ymax * 1.15]),          # запас сверху для подписей
        yaxis2=dict(title="Средний таргет", overlaying="y", side="right"),
        template="plotly_white",
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        margin=dict(t=70, r=70, b=120, l=70),
    )

    if show:
        fig.show()

    # Итоговый датафрейм с метриками по бакетам
    df_lift = g[[
        "bucket", "count", "true_count", "share_true_pct",
        "mean_target", "mean_score", "mean_overall", "lift"
    ]].reset_index(drop=True)

    return df_lift, fig
