def create_sql_query(features, in_table, out_table) -> str:
    """
    генерация SQL запроса для переданного списка фичей из feature registry с JOIN выражений.
    Уникальные JOIN'ы для каждой таблицы, чтобы избежать дублирования.
    """
    features_str = ', '.join(f"'{x}'" for x in features)
    query = f"SELECT * FROM FEATURE_REGISTRY WHERE f_name IN ({features_str})"
    
    df = oracle.read_all(query, engine_cdw)
    
    features_cols = 'in_tbl.client_did, in_tbl.report_date, ' + ','.join(x for x in features)

    # Множество для отслеживания уже добавленных таблиц
    seen_tables = set()
    join_sql = []
    
    for key, config in procedure_params.items():
        matches = df[(df['proc'] == config['procedure'].lower())]
        for _, row in matches.iterrows():
            suffix = config['suffix']
            part = row['online_table']
            
            if pd.notna(part):
                table_name = f"{out_table}_{suffix}_{part}"
                alias = f"{suffix}_{part}"
            else:
                table_name = f"{out_table}_{suffix}"
                alias = f"{suffix}"
            
            # Проверяем, не добавляли ли мы уже эту таблицу
            if table_name not in seen_tables:
                seen_tables.add(table_name)
                join_sql.append(f"LEFT JOIN {table_name} {alias}")
                join_sql.append(f"ON in_tbl.client_did={alias}.client_did AND in_tbl.report_date={alias}.report_date")
    
    final_join = ' '.join(join_sql)
        
    sql_query = f"SELECT /*+parallel(8)*/ {features_cols} FROM {in_table} in_tbl {final_join}"
    return sql_query
