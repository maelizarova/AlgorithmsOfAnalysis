# === Формирование финального датафрейма для выбранного поднабора (без суперкластеров) ===
# Предполагаем, что уже есть source_df_subset (например, subset = df.query("Тип == 'Жалоба'") )
# и в нём присутствует колонка embedding_id, как требуется subset_embeddings_by_source_df.

subset_required_cols = [
    "Номер",
    "Описание претензии",
    "Тип",
    "Подтип",
    "Претензия по продукту",
    "Дата регистрации",
]

subset_base_df = (
    source_df_subset[subset_required_cols + ['embedding_id']]
    .copy()
    .rename(columns={'embedding_id': "id"})
)
subset_base_df["id"] = subset_base_df["id"].astype(int)

subset_cluster_info = (
    cluster_map_with_titles_df[cluster_map_with_titles_df["id"].isin(subset_base_df["id"])]
    [["id", "cluster"]]
    .copy()
)

subset_final_df = (
    subset_cluster_info
    .merge(cluster_titles_df[["cluster", "title", "type", "product", "summary"]], on="cluster", how="left")
    .merge(subset_base_df, on="id", how="left")
)

subset_final_df = subset_final_df[
    [
        "Номер",
        "Описание претензии",
        "Тип",
        "Подтип",
        "Претензия по продукту",
        "Дата регистрации",
        "cluster",
        "title",
        "type",
        "product",
        "summary",
    ]
]

print(f"Финальный датафрейм по подмножеству сформирован: {len(subset_final_df)} строк")
display(subset_final_df.head())

