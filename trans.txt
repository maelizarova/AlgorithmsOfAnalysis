import pandas as pd
from sklearn.model_selection import train_test_split
from typing import Tuple, Union, Optional

def split_train_test_oot(
    data: pd.DataFrame,
    test_size: float = 0.2,
    oot_size: float = 0.1,
    split_by_date: bool = False,
    date_col: Optional[str] = None,
    oot_date: Optional[Union[str, pd.Timestamp]] = None,
    random_state: int = 42
) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
    """
    Разделяет датасет на train, test и OOT (Out-of-Time) выборки.
    
    Параметры:
    -----------
    data : pd.DataFrame
        Исходный датасет.
    test_size : float, default=0.2
        Доля test (если split_by_date=False) или размер тестовой выборки (если split_by_date=True).
    oot_size : float, default=0.1
        Доля OOT (если split_by_date=False) или дата начала OOT (если split_by_date=True).
    split_by_date : bool, default=False
        Если True, разделение по дате, иначе — случайное по процентам.
    date_col : str, optional
        Название колонки с датой (требуется, если split_by_date=True).
    oot_date : str or pd.Timestamp, optional
        Дата, с которой начинается OOT (например, '2023-01-01'). Требуется, если split_by_date=True.
    random_state : int, default=42
        Seed для воспроизводимости случайного разделения.
        
    Возвращает:
    -----------
    Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]
        train, test, oot
        
    Примеры:
    --------
    1. Разделение по процентам:
    >>> train, test, oot = split_train_test_oot(data, test_size=0.2, oot_size=0.1)
    
    2. Разделение по дате (OOT — последние 30 дней):
    >>> train, test, oot = split_train_test_oot(
    ...     data,
    ...     split_by_date=True,
    ...     date_col='date',
    ...     oot_date='2023-12-01',
    ...     test_size=30  # дней между train и test
    ... )
    """
    if split_by_date:
        if date_col is None:
            raise ValueError("При split_by_date=True необходимо указать date_col.")
        if oot_date is None:
            raise ValueError("При split_by_date=True необходимо указать oot_date.")
        
        # Преобразуем в datetime, если нужно
        data[date_col] = pd.to_datetime(data[date_col])
        oot_date = pd.to_datetime(oot_date)
        
        # OOT выборка — всё, что >= oot_date
        oot = data[data[date_col] >= oot_date]
        remaining_data = data[data[date_col] < oot_date]
        
        # Разделяем оставшиеся данные на train и test
        if isinstance(test_size, (int, float)) and test_size < 1:
            # Если test_size — доля (например, 0.2)
            train, test = train_test_split(
                remaining_data,
                test_size=test_size,
                random_state=random_state
            )
        else:
            # Если test_size — количество дней (например, 30)
            test_cutoff = remaining_data[date_col].max() - pd.Timedelta(days=test_size)
            test = remaining_data[remaining_data[date_col] > test_cutoff]
            train = remaining_data[remaining_data[date_col] <= test_cutoff]
    else:
        # Разделение по процентам
        if not (0 < test_size + oot_size < 1):
            raise ValueError("Сумма test_size и oot_size должна быть меньше 1.")
        
        # Сначала выделяем OOT
        train_test, oot = train_test_split(
            data,
            test_size=oot_size,
            random_state=random_state
        )
        # Затем разделяем train и test
        train, test = train_test_split(
            train_test,
            test_size=test_size / (1 - oot_size),
            random_state=random_state
        )
    
    return train, test, oot
