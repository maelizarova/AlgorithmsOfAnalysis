"""
Библиотека для анализа результатов построения и обучения модели
и визуализации графиков с использованием Plotly.

Содержит функции для:
- Анализа размеров выборок и уровня таргета по месяцам
- ROC-кривых и Precision-Recall кривых
- Confusion matrix
- Lift-анализа
- PSI-анализа
- Gini-анализа по месяцам
"""

import pandas as pd
import numpy as np
import plotly.graph_objects as go
from typing import Tuple, Optional, Sequence, Dict, List, Any

from sklearn.metrics import (
    roc_auc_score,
    roc_curve,
    precision_recall_curve,
    average_precision_score,
    confusion_matrix
)


def counts_target_ratio_sample(
    data: pd.DataFrame,
    date_col: str,
    target_col: str,
    title: str = "Размеры и Target rate по месяцам",
    count_series_name: str = "Target count",
    rate_series_name: str = "Target rate",
    show: bool = True
) -> Tuple[pd.DataFrame, go.Figure]:
    """
    Строит график с размерами выборки и долей таргета по месяцам.
    
    Параметры:
    ----------
    data : pd.DataFrame
        Исходные данные
    date_col : str
        Название колонки с датой
    target_col : str
        Название колонки с таргетом (0/1 или доля)
    title : str, optional
        Заголовок графика (по умолчанию "Размеры и Target rate по месяцам")
    count_series_name : str, optional
        Название для серии с количеством (по умолчанию "Target count")
    rate_series_name : str, optional
        Название для серии с долей (по умолчанию "Target rate")
    show : bool, optional
        Показывать ли график (по умолчанию True)
        
    Возвращает:
    -----------
    Tuple[pd.DataFrame, go.Figure]
        Агрегированные данные и Plotly фигура
    """
    df = data.copy()
    df[date_col] = pd.to_datetime(df[date_col], errors="coerce")
    df = df.dropna(subset=[date_col])

    # месяц = начало месяца
    df["month"] = df[date_col].dt.to_period("M").dt.to_timestamp()

    # count = число строк; rate = среднее target (доля)
    df_agg = (
        df.groupby("month", as_index=False)
          .agg(count=(target_col, "size"), sum=(target_col, "sum"), rate=(target_col, "mean"))
          .sort_values("month")
    )

    bar_text = df_agg["count"]
    line_text = [f"{int(round(r*100))}%" if pd.notna(r) else "" for r in df_agg["rate"]]

    ymax = float(df_agg["count"].max() or 0)
    pad = ymax * 0.1  # запас сверху
    y2max = float(df_agg["rate"].max() or 0)
    pad2 = y2max * 0.25  # запас сверху

    fig = go.Figure()

    # БАРЫ с подписями сверху
    fig.add_bar(
        x=df_agg["month"], y=df_agg["count"],
        name=count_series_name,
        text=bar_text,
        textposition="outside",      # подписи над столбцами
        textfont=dict(size=12),
        marker=dict(line=dict(width=0)),
    )

    # ЛИНИЯ таргета (правая ось, проценты)
    fig.add_trace(go.Scatter(
        x=df_agg["month"], y=df_agg["rate"],
        mode="lines+markers+text",
        name=rate_series_name,
        yaxis="y2",
        text=line_text,
        textposition="top center",
        line=dict(width=3, color="#D62728"),
        marker=dict(size=8, line=dict(width=1, color="white")),
    ))

    fig.update_layout(
        title=title,
        xaxis=dict(title=None, tickangle=45),
        # верхний запас по оси Y, чтобы видно было подписи «outside»
        yaxis=dict(title="Количество клиентов",
                   tickformat=",.0f",
                   range=[0, ymax + pad]),
        yaxis2=dict(title="RR, %", overlaying="y", side="right", tickformat=".0%", range=[0, y2max + pad2]),
        bargap=0.25,
        template="plotly_white",
        legend=dict(orientation="h", yanchor="top", y=-0.35, xanchor="right", x=0.5),
        margin=dict(t=70, r=60, b=70, l=70)
    )

    if show:
        fig.show()

    df_agg['rate'] = (df_agg['rate']*100).round(2).astype(str)+'%' #переведем в проценты
    
    return df_agg, fig


def counts_target_ratio(
    train: pd.DataFrame,
    test: pd.DataFrame,
    oot: pd.DataFrame = None,
    date_col: str = "month",
    target_col: str = "target",
    id_col: str = None,
    title: str = "Размеры выборок и уровень таргета по месяцам"
) -> Tuple[pd.DataFrame, go.Figure]:
    """
    Строит график с размерами выборок train/test/oot и уровнем таргета по месяцам.
    
    Параметры:
    ----------
    train : pd.DataFrame
        Обучающая выборка
    test : pd.DataFrame
        Тестовая выборка
    oot : pd.DataFrame, optional
        OOT выборка (по умолчанию None)
    date_col : str, optional
        Название колонки с датой (по умолчанию "month")
    target_col : str, optional
        Название колонки с таргетом (по умолчанию "target")
    id_col : str, optional
        Название колонки с ID для подсчета уникальных значений (по умолчанию None)
    title : str, optional
        Заголовок графика (по умолчанию "Размеры выборок и уровень таргета по месяцам")
        
    Возвращает:
    -----------
    Tuple[pd.DataFrame, go.Figure]
        Агрегированные данные и Plotly фигура
    """
    def _prep(df: pd.DataFrame):
        if df is None or len(df) == 0:
            return pd.DataFrame(columns=["month", "cnt", "rr"])
        tmp = df.copy()
        tmp[date_col] = pd.to_datetime(tmp[date_col])
        tmp["month"] = tmp[date_col].dt.to_period("M").dt.to_timestamp()
        if id_col:
            g = tmp.groupby("month", as_index=False).agg(
                cnt=(id_col, pd.Series.nunique),
                rr=(target_col, "mean")
            )
        else:
            g = tmp.groupby("month", as_index=False).agg(
                cnt=(target_col, "size"),
                rr=(target_col, "mean")
            )
        return g

    g_train = _prep(train).rename(columns={"cnt":"train_cnt","rr":"rr_train"})
    g_test  = _prep(test ).rename(columns={"cnt":"test_cnt","rr":"rr_test"})
    g_oot   = _prep(oot  ).rename(columns={"cnt":"oot_cnt" ,"rr":"rr_oot"})

    # полная сетка месяцев
    months = pd.DataFrame({"month": sorted(set(g_train["month"])|set(g_test["month"])|set(g_oot["month"]))})
    df = (months.merge(g_train, on="month", how="left")
                 .merge(g_test,  on="month", how="left")
                 .merge(g_oot,   on="month", how="left"))
    
    df = df[['month', 'train_cnt', 'test_cnt', 'oot_cnt', 'rr_train', 'rr_test', 'rr_oot']]

    # NaN → 0 только для счетчиков
    for c in ["train_cnt","test_cnt","oot_cnt"]:
        if c in df: df[c] = df[c].fillna(0).astype(int)

    # --- маски для линий (None, где счетчик = 0) ---
    rr_train_y = [v*100 if (pd.notna(v) and cnt>0) else None
                  for v, cnt in zip(df.get("rr_train"), df.get("train_cnt", 0))]
    rr_test_y  = [v*100 if (pd.notna(v) and cnt>0) else None
                  for v, cnt in zip(df.get("rr_test"),  df.get("test_cnt",  0))]
    rr_oot_y   = [v*100 if (pd.notna(v) and cnt>0) else None
                  for v, cnt in zip(df.get("rr_oot"),   df.get("oot_cnt",   0))]

    fig = go.Figure()

    # stacked bars: train + test (+ oot где есть)
    fig.add_bar(x=df["month"], y=df["train_cnt"], name="train_cnt")
    fig.add_bar(x=df["month"], y=df["test_cnt"],  name="test_cnt")
    fig.add_bar(x=df["month"], y=df["oot_cnt"],   name="OOT_cnt")

    # lines on secondary axis, masked by nonzero counts
    fig.add_trace(go.Scatter(x=df["month"], y=rr_train_y, mode="lines+markers",
                             name="RR Train", yaxis="y2", line=dict(color='#17BECF')))
    fig.add_trace(go.Scatter(x=df["month"], y=rr_test_y,  mode="lines+markers",
                             name="RR Test",  yaxis="y2", line=dict(color='#FFD200')))
    fig.add_trace(go.Scatter(x=df["month"], y=rr_oot_y,   mode="lines+markers",
                             name="RR OOT",   yaxis="y2", line=dict(color='#7B61FF')))

    fig.update_layout(
        barmode="stack",
        title=title,
        xaxis=dict(title="Месяц"),
        yaxis=dict(title="Количество клиентов", tickformat=",.0f"),
        yaxis2=dict(title="RR, %", overlaying="y", side="right"),
        legend=dict(orientation="h", yanchor="top", y=-0.35, xanchor="center", x=0.5),
        template="plotly_white"
    )

    # показать и вернуть
    fig.show()

    df = df.fillna(0)
    df['rr_train'] = (df['rr_train']*100).round(2).astype(str)+'%' #переведем в проценты
    df['rr_test'] = (df['rr_test']*100).round(2).astype(str)+'%' #переведем в проценты
    df['rr_oot'] = (df['rr_oot']*100).round(2).astype(str)+'%' #переведем в проценты
    df = df.replace('0.0%', '---')
    df = df.replace(0, '---')
    return df, fig


def roc_curve_plotly(
    y_true: Sequence,
    y_score: Sequence,
    title: str = "ROC curve"
) -> Tuple[pd.DataFrame, go.Figure]:
    """
    Строит ROC-кривую для бинарной классификации.
    
    Параметры:
    ----------
    y_true : Sequence
        1D массив истинных меток (0/1)
    y_score : Sequence
        1D массив скорингов/вероятностей ПОЛОЖИТЕЛЬНОГО класса
    title : str, optional
        Заголовок графика (по умолчанию "ROC curve")
        
    Возвращает:
    -----------
    Tuple[pd.DataFrame, go.Figure]
        DataFrame с FPR/TPR/threshold/AUC и Plotly фигура
    """
    y_true  = np.asarray(y_true)
    y_score = np.asarray(y_score)

    if y_score.ndim != 1:
        raise ValueError("Ожидается 1D массив y_score (например, y_proba[:, 1]).")

    fpr, tpr, thr = roc_curve(y_true, y_score, pos_label=1)
    auc = roc_auc_score(y_true, y_score)

    df_points = pd.DataFrame({
        "fpr": fpr,
        "tpr": tpr,
        "threshold": thr
    })
    df_points["auc"] = auc

    roc_trace = go.Scatter(
        x=fpr, y=tpr,
        mode="lines",
        name=f"ROC {title} (AUC={auc:.3f})",
        hovertemplate="FPR: %{x:.3f}<br>TPR: %{y:.3f}<br>Threshold: %{customdata:.3f}",
        customdata=thr,
        line=dict(width=3)
    )

    fig = go.Figure([roc_trace])
    fig.update_layout(
        title=title,
        xaxis=dict(title="False Positive Rate (FPR)", range=[0, 1]),
        yaxis=dict(title="True Positive Rate (TPR)",  range=[0, 1]),
        template="plotly_white",
        legend=dict(orientation="h", y=-0.35, x=1, xanchor="right", yanchor="top"),
        margin=dict(t=70, r=40, b=50, l=60),
        hovermode="x unified"
    )
    
    return df_points, fig


def precision_recall_curve_plotly(
    y_true: Sequence,
    y_score: Sequence,
    title: str = "Precision–Recall curve"
) -> Tuple[pd.DataFrame, go.Figure]:
    """
    Строит Precision-Recall кривую для бинарной классификации.
    
    Параметры:
    ----------
    y_true : Sequence
        1D массив истинных меток (0/1)
    y_score : Sequence
        1D массив скорингов/вероятностей ПОЛОЖИТЕЛЬНОГО класса
    title : str, optional
        Заголовок графика (по умолчанию "Precision–Recall curve")
        
    Возвращает:
    -----------
    Tuple[pd.DataFrame, go.Figure]
        DataFrame с recall/precision/threshold/average_precision и Plotly фигура
    """
    y_true  = np.asarray(y_true)
    y_score = np.asarray(y_score)
    if y_score.ndim != 1:
        raise ValueError("Ожидается 1D массив y_score (например, y_proba[:, 1]).")

    precision, recall, thresholds = precision_recall_curve(y_true, y_score, pos_label=1)
    ap = average_precision_score(y_true, y_score)
    prevalence = y_true.mean()  # базовый уровень precision у случайного классификатора

    # precision_recall_curve возвращает thresholds на 1 короче
    thr_padded = np.r_[np.nan, thresholds]

    df_points = pd.DataFrame({
        "recall": recall,
        "precision": precision,
        "threshold": thr_padded
    })
    df_points["average_precision"] = ap
    df_points["prevalence"] = prevalence

    # График
    fig = go.Figure()
    
    # PR-кривая
    fig.add_trace(go.Scatter(
        x=recall, y=precision,
        mode="lines",
        name=f"PR {title} (AP={ap:.3f})",
        customdata=thr_padded,
        hovertemplate="Recall: %{x:.3f}<br>Precision: %{y:.3f}<br>Threshold: %{customdata:.3f}",
        line=dict(width=3)
    ))

    fig.update_layout(
        title=title,
        xaxis=dict(title="Recall", range=[0, 1], tickformat=".2f"),
        yaxis=dict(title="Precision", range=[0, 1], tickformat=".2f"),
        template="plotly_white",
        legend=dict(orientation="h", y=1.02, x=1, xanchor="right", yanchor="bottom"),
        margin=dict(t=70, r=40, b=50, l=60),
        hovermode="x unified"
    )

    return df_points, fig


def confusion_matrix_plotly(
    y_true: Sequence,
    y_pred: Optional[Sequence] = None,
    y_score: Optional[Sequence] = None,
    threshold: float = 0.5,
    title: str = "Confusion matrix"
) -> Tuple[pd.DataFrame, go.Figure]:
    """
    Строит матрицу ошибок (confusion matrix) в виде тепловой карты.
    
    Параметры:
    ----------
    y_true : Sequence
        1D массив истинных меток
    y_pred : Optional[Sequence], optional
        1D массив предсказанных меток (по умолчанию None)
    y_score : Optional[Sequence], optional
        1D массив скорингов для преобразования в метки через threshold (по умолчанию None)
    threshold : float, optional
        Порог для преобразования y_score в метки (по умолчанию 0.5)
    title : str, optional
        Заголовок графика (по умолчанию "Confusion matrix")
        
    Возвращает:
    -----------
    Tuple[pd.DataFrame, go.Figure]
        DataFrame с матрицей ошибок и Plotly фигура
    """
    y_true = np.asarray(y_true)

    if y_pred is None:
        if y_score is None:
            raise ValueError("Ожидается либо y_pred, либо y_score + threshold.")
        y_score = np.asarray(y_score)
        if y_score.ndim != 1:
            raise ValueError("y_score должен быть 1D (например, y_proba[:, 1]).")
        y_pred = (y_score >= threshold).astype(int)
    else:
        y_pred = np.asarray(y_pred)

    # фиксируем порядок меток по объединению y_true и y_pred
    labels = np.unique(np.concatenate([y_true, y_pred]))

    cm = confusion_matrix(y_true, y_pred, labels=labels)  # абсолюты
    df_cm = pd.DataFrame(cm, index=labels, columns=labels)

    fig = go.Figure(
        data=go.Heatmap(
            z=df_cm.values,
            x=[str(x) for x in df_cm.columns],
            y=[str(y) for y in df_cm.index],
            colorscale="Blues",
            colorbar=dict(title="Count"),
            text=df_cm.values.astype(int),
            texttemplate="%{text}",
            textfont=dict(size=12),
            hovertemplate="True: %{y}<br>Pred: %{x}<br>Count: %{z}<extra></extra>"
        )
    )
    fig.update_layout(
        title=title,
        xaxis=dict(title="Predicted"),
        yaxis=dict(title="True", autorange="reversed"),
        template="plotly_white",
        margin=dict(t=70, r=40, b=60, l=70)
    )
    fig.show()
    return df_cm, fig


def model_results_plotly(
    df_train: pd.DataFrame,
    df_test: pd.DataFrame,
    df_oot: pd.DataFrame,
    target_name: str,
    features: List[str],
    model: Any
) -> Tuple[pd.DataFrame, go.Figure, go.Figure, List[go.Figure], List[go.Figure]]:
    """
    Комплексный анализ результатов модели: ROC, PR, Confusion Matrix, Lift.
    
    Параметры:
    ----------
    df_train : pd.DataFrame
        Обучающая выборка
    df_test : pd.DataFrame
        Тестовая выборка
    df_oot : pd.DataFrame
        OOT выборка
    target_name : str
        Название колонки с таргетом
    features : List[str]
        Список признаков для модели
    model : Any
        Обученная модель с методами predict и predict_proba
        
    Возвращает:
    -----------
    Tuple[pd.DataFrame, go.Figure, go.Figure, List[go.Figure], List[go.Figure]]
        Таблица метрик, ROC график, PR график, Lift графики, Confusion Matrix графики
    """
    from sklearn.metrics import (
        accuracy_score, precision_score, recall_score, f1_score,
        roc_auc_score, fbeta_score
    )
    
    X_train, y_train = df_train[features], df_train[target_name]
    X_test, y_test = df_test[features], df_test[target_name]
    X_oot, y_oot = df_oot[features], df_oot[target_name]
    
    # Предикты
    y_train_pred_proba = model.predict_proba(X_train)[:,1]
    y_test_pred_proba = model.predict_proba(X_test)[:,1]
    y_oot_pred_proba = model.predict_proba(X_oot)[:,1]

    y_train_pred = model.predict(X_train)
    y_test_pred = model.predict(X_test)
    y_oot_pred = model.predict(X_oot)
    
    N_feat = len(features)
    
    # Метрики
    train_N = X_train.shape[0]
    test_N = X_test.shape[0]
    oot_N = X_oot.shape[0]
    
    train_share = y_train.mean()
    test_share = y_test.mean()
    oot_share = y_oot.mean()
    
    train_roc = round(roc_auc_score(y_train, y_train_pred_proba), 3)
    test_roc = round(roc_auc_score(y_test, y_test_pred_proba), 3)
    oot_roc = round(roc_auc_score(y_oot, y_oot_pred_proba), 3)
    
    train_gini = 2 * train_roc - 1
    test_gini = 2 * test_roc - 1
    oot_gini = 2 * oot_roc - 1
    
    train_rec = round(recall_score(y_train, y_train_pred), 3)
    test_rec = round(recall_score(y_test, y_test_pred), 3)
    oot_rec = round(recall_score(y_oot, y_oot_pred), 3)
    
    train_prec = round(precision_score(y_train, y_train_pred), 3)
    test_prec = round(precision_score(y_test, y_test_pred), 3)
    oot_prec = round(precision_score(y_oot, y_oot_pred), 3)
    
    train_f1 = round(f1_score(y_train, y_train_pred), 3)
    test_f1 = round(f1_score(y_test, y_test_pred), 3)
    oot_f1 = round(f1_score(y_oot, y_oot_pred), 3)
    
    train_fbeta2 = round(fbeta_score(y_train, y_train_pred, beta=2), 3)
    test_fbeta2 = round(fbeta_score(y_test, y_test_pred, beta=2), 3)
    oot_fbeta2 = round(fbeta_score(y_oot, y_oot_pred, beta=2), 3)
    
    train_fbeta05 = round(fbeta_score(y_train, y_train_pred, beta=0.5), 3)
    test_fbeta05 = round(fbeta_score(y_test, y_test_pred, beta=0.5), 3)
    oot_fbeta05 = round(fbeta_score(y_oot, y_oot_pred, beta=0.5), 3)

    # ROC кривые
    _, roc_fig_train = roc_curve_plotly(y_train, y_train_pred_proba, "Train")
    _, roc_fig_test = roc_curve_plotly(y_test, y_test_pred_proba, "Test")
    _, roc_fig_oot = roc_curve_plotly(y_oot, y_oot_pred_proba, "OOT")

    fig_roc = go.Figure()
    for f in [roc_fig_train, roc_fig_test, roc_fig_oot]:
        for tr in f.data:
            fig_roc.add_trace(tr)
    # Линия 'chance'
    fig_roc.add_trace(go.Scatter(
        x=[0, 1], y=[0, 1],
        mode="lines",
        name="Chance",
        line=dict(width=2, dash="dash", color="#999"),
        hoverinfo="skip"
    ))
    fig_roc.update_layout(
        title='ROC curve Train/Test/OOT',
        xaxis=dict(title="False Positive Rate (FPR)", range=[0, 1]),
        yaxis=dict(title="True Positive Rate (TPR)",  range=[0, 1]),
        template="plotly_white",
        legend=dict(orientation="h", y=-0.35, x=1, xanchor="right", yanchor="top"),
        margin=dict(t=70, r=40, b=50, l=60),
        hovermode="x unified"
    )
    fig_roc.show()

    # precision_recall кривая 
    _, pr_fig_train = precision_recall_curve_plotly(y_train, y_train_pred_proba, "Train")
    _, pr_fig_test = precision_recall_curve_plotly(y_test, y_test_pred_proba, "Test") 
    _, pr_fig_oot = precision_recall_curve_plotly(y_oot, y_oot_pred_proba, "OOT") 

    fig_pr = go.Figure()
    for f in [pr_fig_train, pr_fig_test, pr_fig_oot]:
        for tr in f.data:
            fig_pr.add_trace(tr)

    fig_pr.update_layout(
        title='Precision-Recall curve Train/Test/OOT',
        xaxis=dict(title="Recall", range=[0, 1]),
        yaxis=dict(title="Precision",  range=[0, 1]),
        template="plotly_white",
        legend=dict(orientation="h", y=-0.35, x=1, xanchor="right", yanchor="top"),
        margin=dict(t=70, r=40, b=50, l=60),
        hovermode="x unified"
    )
    fig_pr.show()

    # Confusion Matrix
    _, cm_fig_train = confusion_matrix_plotly(y_true=y_train, y_score=y_train_pred_proba, threshold=0.5, title="Train")
    _, cm_fig_test = confusion_matrix_plotly(y_true=y_test, y_score=y_test_pred_proba, threshold=0.5, title="Test")
    _, cm_fig_oot = confusion_matrix_plotly(y_true=y_oot, y_score=y_oot_pred_proba, threshold=0.5, title="OOT")
    
    # Таблица с результатами
    res = {'train': [train_N, N_feat, train_share, train_roc, train_gini, train_rec, 
                     train_prec, train_fbeta05, train_f1, train_fbeta2],
           'test': [test_N, N_feat, test_share, test_roc, test_gini, test_rec, 
                    test_prec, test_fbeta05, test_f1, test_fbeta2],
           'oot': [oot_N, N_feat, oot_share, oot_roc, oot_gini, oot_rec, 
                   oot_prec, oot_fbeta05, oot_f1, oot_fbeta2]}
    res_df = pd.DataFrame(data=res, index=['N_samples', 'N_feat', 'target_share', 'ROC', 'gini', 
                                           'Recall', 'Precision', 'f05_score','f1_score', 'f2_score'])
    
    # Лифты
    df_train_tmp = pd.DataFrame()
    df_train_tmp['target'] = y_train
    df_train_tmp['pred'] = y_train_pred_proba
    _, lift_fig_train = lift_plotly(df_train_tmp, 'pred', 'target', 'Лифт train')
    
    df_test_tmp = pd.DataFrame()
    df_test_tmp['target'] = y_test
    df_test_tmp['pred'] = y_test_pred_proba
    _, lift_fig_test = lift_plotly(df_test_tmp, 'pred', 'target', 'Лифт test')
    
    df_oot_tmp = pd.DataFrame()
    df_oot_tmp['target'] = y_oot
    df_oot_tmp['pred'] = y_oot_pred_proba
    _, lift_fig_oot = lift_plotly(df_oot_tmp, 'pred', 'target', 'Лифт oot')
      
    return res_df, fig_roc, fig_pr, [lift_fig_train, lift_fig_test, lift_fig_oot], [cm_fig_train, cm_fig_test, cm_fig_oot]


def lift_plotly(
    df: pd.DataFrame,
    pred_col: str,
    target_col: str,
    name: str = "Лифт",
    q: int = 10,
    show: bool = True
) -> Tuple[pd.DataFrame, go.Figure]:
    """
    Строит лифт-график по децилям предсказанного скора.
    
    Параметры:
    ----------
    df : pd.DataFrame
        Исходные данные
    pred_col : str
        Название колонки с предсказаниями/скором
    target_col : str
        Название колонки с таргетом
    name : str, optional
        Название для заголовка графика (по умолчанию "Лифт")
    q : int, optional
        Количество квантилей (по умолчанию 10)
    show : bool, optional
        Показывать ли график (по умолчанию True)
        
    Возвращает:
    -----------
    Tuple[pd.DataFrame, go.Figure]
        DataFrame с метриками по бакетам и Plotly фигура
        
    Колонки df_lift:
        bucket (1..q), count, true_count, share_true_pct,
        mean_target, mean_score, mean_overall, lift
    """
    data = df[[pred_col, target_col]].dropna().copy()

    # Децильные "бакеты" по предсказанию
    # метки делаем 1..q (1 = низкие скора, q = высокие)
    data["bucket"] = pd.qcut(data[pred_col], q=q, labels=range(1, q + 1), duplicates="drop")

    # Агрегация по бакетам
    g = (
        data.groupby("bucket", observed=False)
            .agg(
                mean_target=(target_col, "mean"),
                mean_score=(pred_col, "mean"),
                count=(target_col, "size"),
                true_count=(target_col, "sum"),
            )
            .reset_index()
            .astype({"bucket": int})
            .sort_values("bucket")
    )

    mean_overall = data[target_col].mean()
    g["mean_overall"] = mean_overall
    g["lift"] = g["mean_target"] / mean_overall if mean_overall > 0 else 0.0

    total_true = data[target_col].sum()
    g["share_true_pct"] = np.where(total_true > 0, g["true_count"] / total_true * 100.0, 0.0)

    # ------- Рисуем -------
    fig = go.Figure()

    # Бар: Lift (левая ось)
    fig.add_bar(
        x=g["bucket"], y=g["lift"],
        name="Lift",
        marker_color="silver",
        textposition="outside",
        cliponaxis=False
    )

    # Линии: средний таргет в бакете, средний скор, средний по выборке (константа), правая ось
    fig.add_trace(go.Scatter(
        x=g["bucket"], y=g["mean_target"],
        mode="lines", name="Средний таргет в бакете",
        yaxis="y2", line=dict(width=3)
    ))
    fig.add_trace(go.Scatter(
        x=g["bucket"], y=g["mean_score"],
        mode="lines", name="Средний скор в бакете",
        yaxis="y2", line=dict(width=3, color="#FF7F0E")
    ))
    fig.add_trace(go.Scatter(
        x=g["bucket"], y=g["mean_overall"],
        mode="lines", name="Средний таргет в выборке",
        yaxis="y2", line=dict(width=2, dash="dash", color="#2ca02c")
    ))

    # Подписи «Доля true единиц» под осью X
    fig.add_annotation(
        xref="paper", yref="paper", x=0, y=-0.16,
        text="Доля true единиц", showarrow=False, align="left"
    )
    for x_i, pct in zip(g["bucket"], g["share_true_pct"]):
        fig.add_annotation(
            x=x_i, yref="paper", y=-0.22,
            text=f"{pct:.1f}%", showarrow=False
        )

    # Оси и оформление
    ymax = float(max(1.0, g["lift"].max()))
    fig.update_layout(
        title=f"{name}",
        xaxis=dict(tickmode="array", tickvals=g["bucket"]),
        yaxis=dict(title="Лифт", range=[0, ymax * 1.15]),          # запас сверху для подписей
        yaxis2=dict(title="Средний таргет", overlaying="y", side="right"),
        template="plotly_white",
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        margin=dict(t=70, r=70, b=120, l=70)
    )

    if show:
        fig.show()

    # Итоговый датафрейм с метриками по бакетам
    df_lift = g[[
        "bucket", "count", "true_count", "share_true_pct",
        "mean_target", "mean_score", "mean_overall", "lift"
    ]].reset_index(drop=True)

    return df_lift, fig


def psi_plotly(
    psi_pivot: pd.DataFrame,
    title: str = "PSI по месяцам",
    thresholds: Tuple[float, float] = (0.10, 0.25)
) -> Tuple[pd.DataFrame, go.Figure]:
    """
    Строит график PSI (Population Stability Index) по месяцам.
    
    Параметры:
    ----------
    psi_pivot : pd.DataFrame
        DataFrame с PSI значениями
        index  -> имена фичей
        columns-> даты (datetime или строки)
        values -> PSI (float)
    title : str, optional
        Заголовок графика (по умолчанию "PSI по месяцам")
    thresholds : Tuple[float, float], optional
        Пороговые значения для референс-линий (по умолчанию (0.10, 0.25))
        
    Возвращает:
    -----------
    Tuple[pd.DataFrame, go.Figure]
        DataFrame в long-формате ['feature','date','psi'] и Plotly фигура
    """
    if psi_pivot.empty:
        raise ValueError("psi_pivot пуст.")

    # long-формат для ВСЕХ фичей из индекса
    df_long = (
        psi_pivot.assign(feature=lambda d: d.index)
                 .reset_index(drop=True)
                 .melt(id_vars="feature", var_name="date", value_name="psi")
    )
    # даты -> datetime (если распарсятся)
    df_long["date"] = pd.to_datetime(df_long["date"], errors="coerce")
    df_long = df_long.sort_values(["feature", "date"]).reset_index(drop=True)

    def shorten_name(text, max_len=41):
        return text if len(text) <= max_len else text[:max_len] + '...'
        
    # фигура
    fig = go.Figure()
    for f, part in df_long.groupby("feature", sort=False):
        fig.add_trace(go.Scatter(
            x=part["date"], y=part["psi"],
            mode="lines+markers",
            name=shorten_name(str(f)),
            hovertemplate=f"<b>{f}</b><br>Дата: %{{x|%Y-%m-%d}}<br>PSI: %{{y:.4f}}<extra></extra>",
            line=dict(width=3),
            marker=dict(size=6, line=dict(width=1, color="white"))
        ))

    # референс-линии PSI
    for thr in thresholds:
        fig.add_hline(y=thr, line_dash="dash", line_color="#888",
                      annotation_text=f"{thr:.2f}", annotation_position="top left")

    ymax = np.nanmax(df_long["psi"].values)
    fig.update_layout(
        title=title,
        xaxis=dict(),
        yaxis=dict(title="PSI", range=[0, max(0.2, float(ymax)*1.3)]),
        template="plotly_white",
        legend=dict(orientation="h", yanchor="top", y=-0.25, xanchor="left", x=0),
        margin=dict(t=70, r=40, b=60, l=60)
    )

    return df_long, fig


def decile_target(
    df: pd.DataFrame,
    score_col: str,
    target_col: str,
    id_col: str,
    q: int = 10,
    as_percent: bool = True
) -> pd.DataFrame:
    """
    Анализ таргета по децилям скора.
    
    Параметры:
    ----------
    df : pd.DataFrame
        Исходные данные
    score_col : str
        Название колонки со скором/вероятностью
    target_col : str
        Название колонки с таргетом (0/1)
    id_col : str
        Название колонки с ID клиента
    q : int, optional
        Количество квантилей (по умолчанию 10)
    as_percent : bool, optional
        Возвращать ratio в процентах (по умолчанию True)
        
    Возвращает:
    -----------
    pd.DataFrame
        DataFrame с колонками: decile, client_all, target_0, target_1, ratio
    """
    d = df[[score_col, target_col] + ([id_col] if id_col else [])].dropna().copy()

    # Дециль: 1 = максимум score
    d["decile"] = pd.qcut(-d[score_col], q=q, labels=False, duplicates="drop") + 1

    # target_0 / target_1 по децилям
    pivot = (
        d.groupby(["decile", target_col])[id_col]
         .nunique()
         .unstack(fill_value=0)
         .rename(columns={0: "target_0", 1: "target_1"})
         .reset_index()
         .sort_values("decile")
    )

    # всего клиентов в дециле
    pivot["client_all"] = pivot["target_0"] + pivot["target_1"]

    # доля target=1 в дециле от общего числа target=1 по всей выборке
    total_pos = pivot["target_1"].sum()
    pivot["ratio"] = pivot["target_1"] / total_pos if total_pos > 0 else 0.0

    # формат процентов по желанию
    if as_percent:
        pivot["ratio"] = (pivot["ratio"] * 100).round(2).astype(str) + "%"

    # привести тип decile к int (а не category)
    pivot["decile"] = pivot["decile"].astype(int)

    # финальные колонки в нужном порядке
    pivot = pivot[["decile", "client_all", "target_0", "target_1", "ratio"]]
    pivot.columns.name = None
    return pivot


def gini_rate_plotly(
    data: pd.DataFrame,
    date_col: str,
    target_col: str,
    score_col: str,
    title: str = "Gini by months"
) -> Tuple[pd.DataFrame, go.Figure]:
    """
    Строит график с количеством записей (столбики) и Gini (линия) по месяцам.
    
    Параметры:
    ----------
    data : pd.DataFrame
        Исходные данные
    date_col : str
        Название колонки с датой
    target_col : str
        Название колонки с таргетом (0/1)
    score_col : str
        Название колонки с вероятностью/скором позитивного класса
    title : str, optional
        Заголовок графика (по умолчанию "Gini by months")
        
    Возвращает:
    -----------
    Tuple[pd.DataFrame, go.Figure]
        DataFrame с агрегированными данными и Plotly фигура
        
    Примечание:
    -----------
    Gini для каждого месяца = 2 * AUC - 1
    """
    df = data[[date_col, target_col, score_col]].copy()
    df[date_col] = pd.to_datetime(df[date_col], errors="coerce")
    df = df.dropna(subset=[date_col])

    # месяц = начало месяца
    df["month"] = df[date_col].dt.to_period("M").dt.to_timestamp()

    # cnt по месяцам
    agg_cnt = df.groupby("month", as_index=False).agg(cnt=(target_col, "size"))

    # gini по месяцам
    def _gini_month(gr: pd.DataFrame) -> float:
        y = gr[target_col].values
        s = gr[score_col].values
        if len(np.unique(y)) < 2:
            return np.nan  # AUC не определён, если в месяце один класс
        auc = roc_auc_score(y, s)
        return 2 * auc - 1

    gini = df.groupby("month").apply(_gini_month).reset_index(name="gini")

    df_agg = (
        agg_cnt.merge(gini, on="month", how="left")
               .sort_values("month")
               .reset_index(drop=True)
    )

    # --- Plotly ---
    fig = go.Figure()
    fig.add_bar(
        x=df_agg["month"], y=df_agg["cnt"],
        name="CNT",
        marker_color="royalblue", opacity=0.9
    )
    fig.add_trace(go.Scatter(
        x=df_agg["month"], y=df_agg["gini"],
        mode="lines+markers",
        name="GINI",
        yaxis="y2",
        line=dict(width=3, color="red"),
        marker=dict(size=7, line=dict(width=1, color="white"))
    ))

    fig.update_layout(
        title=title,
        xaxis=dict(title=None, tickangle=45),
        yaxis=dict(title="CNT", tickformat=",.0f", color="royalblue",
                   titlefont=dict(color="royalblue")),
        yaxis2=dict(title="GINI", overlaying="y", side="right",
                    range=[0, 1], tickformat=".2f",
                    color="red", titlefont=dict(color="red")),
        template="plotly_white",
        legend=dict(orientation="h", yanchor="top", y=-0.35,
                    xanchor="center", x=0.5),
        margin=dict(t=70, r=70, b=70, l=70)
    )

    fig.show()

    return df_agg[["month", "cnt", "gini"]], fig
