# Альтернативная версия если нет ID, но есть порядковый номер
def create_final_dataframe_by_index(merged_results_file, original_df):
    """
    Создает итоговый датафрейм по порядковому номеру
    """
    
    # Загружаем результаты классификации
    with open(merged_results_file, 'r', encoding='utf-8') as f:
        classification_results = json.load(f)
    
    # Создаем датафрейм из результатов классификации
    results_data = []
    for result in classification_results:
        classification = result.get('classification', {})
        row_data = {
            'index': result['id'] - 1,  # преобразуем в индекс (начинается с 0)
            'исходный_текст_жалобы': result['original_text'],
            'продукт': classification.get('product', 'НЕОПРЕДЕЛЕН'),
            'тип_жалобы': classification.get('complaint_type', 'ДРУГОЕ'),
            'подтип_жалобы': classification.get('complaint_subtype', 'ДРУГОЕ'),
            'уверенность': classification.get('confidence', 'низкая'),
            'обоснование': classification.get('explanation', '')
        }
        results_data.append(row_data)
    
    classification_df = pd.DataFrame(results_data)
    classification_df = classification_df.set_index('index')
    
    # Объединяем с исходным датафреймом по индексу
    final_df = original_df.copy()
    for col in ['продукт', 'тип_жалобы', 'подтип_жалобы', 'уверенность', 'обоснование']:
        final_df[col] = classification_df[col]
    
    # Добавляем колонку с исходным текстом из классификации для проверки
    final_df['исходный_текст_жалобы_классификация'] = classification_df['исходный_текст_жалобы']
    
    return final_df
